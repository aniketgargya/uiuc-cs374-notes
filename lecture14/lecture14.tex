\documentclass[12pt]{article}
\usepackage{../lecture}
\lecture{14}{More Dynamic Programming}
\date{March 16, 2021}

\begin{document}
\maketitle

\section{More Text Segmentation}
\begin{itemize}
    \item \textit{Input}: A string $w \in \sum^{\ast}$ and access to a language $L \subseteq \sum^{\ast}$ via function \texttt{IsStringInL(string x)} that decides whether $x$ is in $L$, and non-negative integer $k$.
    \item \textit{Goal}: Decide if $w \in L^k$ using \texttt{IsStringInL(string x)} as a black box sub-routine.
    \item $w \in L^k \implies$:
    \begin{itemize}
        \item $k = 0 \iff w = \epsilon$
        \item $k = 1 \iff w \in L$
        \item $k > 1 \implies w = uv \mid  u \in L, v \in L^{k - 1}$
    \end{itemize}
\end{itemize}

\subsection{Algorithm and Analysis}
\begin{itemize}
    \item[] \lstinputlisting{code/is-string-in-L-k.sudo}
    \item $O(nk)$ distinct sub-problems are generated by \texttt{IsStringInLk(A[1...n], k)}.
    \item This requires $O(nk)$ space.
    \item For each entry ($O(nk)$ entries), we need to loop from $i$ to $n - 1$, so it is $O(n^2k)$ running time.
\end{itemize}

\subsection{Recursive Equation}
\begin{itemize}
    \item \texttt{ISLk(i, h)}: a boolean $0$ or $1$.
    \item \textit{Base Case}: \texttt{ISLk(n + 1, 0)} $= 1$ interpreting $A[n + 1...n]$ as $\epsilon$.
    \item \textit{Recursive Relation}:
    \begin{itemize}
        \item \texttt{ISLk(n + 1, 0)} $= 1$ if $\exists i < j \leq n + 1$ such that \texttt{ISLk(j, h - 1)} $= 1$ and \texttt{IsStringInL(A[i...(j - 1)])} $= 1$.
        \item \texttt{ISLk(i, h)} $= 0$ otherwise.
    \end{itemize}
    \item \texttt{ISLk(i, h)} $= max_{i < j \leq n + 1}\texttt{ISLk(j, h - 1) }\times$ \texttt{IsStringInL(A[i...(j - 1)])} alternatively.
\end{itemize}

\subsection{Iterative Algorithm}
\begin{itemize}
    \item[] \lstinputlisting{code/is-string-in-L-star-iterative.sudo}
    \item Runtime: $O(n^2k)$ 
    \item Space: $O(nk)$ 
\end{itemize}

\section{Edit Distance and Sequence Alignment}

\subsection{Spell Checking Problem}
\begin{itemize}
    \item Given two strings $x_1x_2...x_n$ and $y_1y_2...y_m$ the distance between them is the minimum number of "edits" needed to transform $x$ into $y$.
\end{itemize}

\subsection{Edit Distance}
\begin{itemize}
    \item \textbf{Edit Distance}: the number of letter insertions, letter deletions, and letter substitutions required to obtain one string from another.
    \begin{itemize}
        \item The edit distance between FOOD and MONEY is 4.
        \item \underline{F}OOD $\rightarrow$ MO\underline{O}D $\rightarrow$ MON\underline{O}D $\rightarrow$ MONE\underline{D} $\rightarrow$ MONEY
    \end{itemize}
\end{itemize}

\subsection{Edit Distance: Alignment}
\begin{itemize}
    \item Another view is alignment. Place the words on top of the other, with gaps in the first word indicating insertions, and gaps in the second word indicating deletions.
    \item[] 
        \begin{center}
            \begin{tabular}{c c c c c}
                F & O & O &  & D \\
                M & O & N & E & Y \\
            \end{tabular}
        \end{center}
    \item Formally, an \textbf{alignment} is a set $M$ of pairs $(i, j)$ such that each index appears at most once, and there is no "crossing": $i < i'$ and $i$ is matched to $j$ implies $i'$ is matched to $j' > j$. In the above example, this is $M = \{ (1, 1), (2, 2), (3, 3), (4, 5) \}$.
    \item The cost of alignment is the number of columns that do not contain the same letter twice.
\end{itemize}

\subsection{Edit Distance Problem}
\begin{itemize}
    \item Given two words, find the edit distance between them. In other words, find the alignment of smallest cost.
    \item Applications include:
    \begin{itemize}
        \item Spell Checkers and Dictionaries
        \item Unix \texttt{diff}
        \item DNA sequence alignment
    \end{itemize}
\end{itemize}

\subsection{Similarity Metric}
\begin{itemize}
    \item For two strings $X$ and $Y$, the cost of alignment $M$ is
    \begin{itemize}
        \item For each gap in the alignment, we incur a cost $\delta$. (Gap penalty)
        \item For each pair $p$ and $q$ that have been matched in $M$, we incur cost $\alpha_{pq}$; typically, $\alpha_{pp} = 0$.
    \end{itemize}
    \item Edit distance is a special case when $\delta = \alpha_{pq} = 1$.
    \item For this example, Cost $= 2\delta + \alpha_{ae}$
        \begin{center}
            \begin{tabular}{c c c c c c c c c c c}
                o & c &  & u & r &  & a & n & c & e \\
                o & c & c & u & r & r & e & n & c & e \\
            \end{tabular}
        \end{center}
\end{itemize}

\subsection{Sequence Alignment}
\begin{itemize}
    \item \textit{Input}: Given two words $X$ and $Y$, and gap penalty $\delta$ and mismatch costs $\alpha_{pq}$.
    \item \textit{Goal}: Find the alignment of minimum cost.
    \item Basic Observation:
    \begin{itemize}
        \item Let $X = \alpha x$ and $Y = \beta y$, such that $\alpha, \beta \in \sum^{\ast}$ and $x, y \in \sum$.
        \item Think about optimal edit distance between $X$ and $Y$ as alignment, and consider the last column of alignment of the two strings. The prefixes must have optimal alignment.
        \begin{center}
            \begin{tabular}{c c | c c | c c}
                $\alpha$ & $x$ & $\alpha$ & $x$ & $\alpha x$ & \\
                $\beta$ & $y$ & $\beta y$ &  & $\beta$ & $y$ \\
            \end{tabular}
        \end{center}
    \end{itemize}
    \item Another Observation:
    \begin{itemize}
        \item Let $X = x_1x_2...x_m$ and $Y = y_1y_2...y_n$. If $(m, n)$ are not matched, then either the $m$th position of $X$ remains unmatched or the $n$th position of $Y$ remains unmatched.
        \item Case $x_m$ and $y_n$ are matched: Pay mismatch cost $\alpha_{x_my_m}$ plus cost of aligning strings $x_1...x_{m-1}$ and $y_1...x_{n-1}$.
        \item Case $x_m$ is unmatched: Pay gap penalty plus cost of aligning $x_1...x_{m-1}$ and $y_1...y_n$.
        \item Case $y_n$ is unmatched: Pay gap penalty plus cost of aligning $x_1...x_m$ and $y_1...y_{n-1}$.
    \end{itemize}
\end{itemize}

\subsubsection{Algorithm}
\begin{itemize}
    \item Assume $X$ is stored in array $A[1...m]$ and $Y$ is stored in $B[1...n]$, function \texttt{cost} stores the cost of matching two characters.
    \item[] \lstinputlisting{code/edit-distance-recursive.sudo}
    \item \texttt{EditDistance(A[1...m], B[1...n])} will generate $O(nm)$ distinct sub-problems.
    \item If we memoize the recursion, the runtime is $O(nm)$ since each call takes $O(1)$ time to assemble the answer from recursive calls and no other computation.
    \item Let \texttt{Opt($i$, $j$)} be the optimal cost of aligning $x_1...x_i$ and $y_1...y_j$.
    \begin{equation}
        \texttt{Opt}(i, j) = \begin{cases}
            \texttt{min} \left\{
                \begin{tabular}{c}
                    $\alpha_{x_iy_j} + \texttt{Opt}(i - 1, j - 1)$ \\
                    $\delta + \texttt{Opt}(i - 1, j)$ \\
                    $\delta + \texttt{Opt}(i, j - 1)$ \\
                \end{tabular}
            \right\} & \text{otherwise} \\
            \delta \times i & j = 0 \\
            \delta \times j & i = 0 \\
        \end{cases}
    \end{equation}
    \item[] \lstinputlisting{code/edit-distance-iterative.sudo}
    \item The running time is $O(nm)$ and the space is $O(nm)$.
    \item We can reduce the space as entries in the $j$th column only depend on the $(j - 1)$th column and earlier entires in the $j$th column. We will only store the current column and the previous column reusing space.
    \item This optimization keeps the running time at $O(mn)$ and reduces the space to $O(2m) = O(m)$.
\end{itemize}

\end{document} 
